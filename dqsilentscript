-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- Variables to store character components
local humanoidRootPart, humanoid
local currentTween  -- Store the current tween so we can stop it during dodging
local dodgingParts = {}  -- Table to store active parts that trigger dodges

-- Function to initialize character components after respawn
local function initializeCharacter(character)
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
end

-- Attach to the CharacterAdded event to ensure the script continues after respawn
LocalPlayer.CharacterAdded:Connect(function(character)
    initializeCharacter(character)
end)

-- Initialize the character if already loaded
if LocalPlayer.Character then
    initializeCharacter(LocalPlayer.Character)
end

-- Function to cancel current tweening movement
local function stopTween()
    if currentTween then
        currentTween:Cancel()
        currentTween = nil  -- Clear the tween reference after stopping
    end
end

-- Function to dodge away from a part
local function dodgeAllParts()
    -- Check each part in the dodgingParts table
    for _, part in pairs(dodgingParts) do
        if not part or not part:IsDescendantOf(Workspace) then
            -- Remove part if it no longer exists in the workspace
            table.remove(dodgingParts, _)
        elseif humanoidRootPart then
            -- Calculate the distance to the part
            local distanceToPart = (part.Position - humanoidRootPart.Position).Magnitude

            -- If the part is within the dodge range, teleport the player away
            if distanceToPart <= getgenv().dodgeRange then
                -- Stop tweening to ensure dodge works
                stopTween()

                -- Calculate a position outside the part's range (teleport in the opposite direction)
                local direction = (humanoidRootPart.Position - part.Position).Unit  -- Direction vector away from the part
                local teleportPosition = humanoidRootPart.Position + direction * (getgenv().dodgeRange + 5)  -- Move farther away

                -- Teleport the whole character using CFrame
                humanoidRootPart.CFrame = CFrame.new(teleportPosition)

                -- Wait for a fixed fast dodge time
                wait(getgenv().dodgeTime)

                -- Wait until all parts in dodgingParts are gone before resuming tweening
                while #dodgingParts > 0 do
                    wait(0.05)  -- Keep checking if the parts are still present
                    for i = #dodgingParts, 1, -1 do
                        if not dodgingParts[i]:IsDescendantOf(Workspace) then
                            table.remove(dodgingParts, i)  -- Remove the part if it no longer exists
                        end
                    end
                end
            end
        end
    end
end

-- Monitor for parts added to the workspace
Workspace.ChildAdded:Connect(function(newObject)
    if newObject:IsA("Part") then
        -- Add the new part to the dodgingParts table
        table.insert(dodgingParts, newObject)
        -- Start dodging all detected parts immediately
        dodgeAllParts()
    end
end)

-- Function to attack the enemy rapidly
local function attackEnemy()
    local args = {
        [1] = {
            [1] = {
                ["animationLength"] = 0,
                ["sentAt"] = tick()  -- Use tick() to get the current time
            },
            [2] = "C"
        }
    }
    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
end

-- Continuous fast attack loop (optimized)
coroutine.wrap(function()
    while getgenv().autofarm do
        pcall(function()
            attackEnemy()
        end)
        wait(0.05)  -- Adjusted attack frequency to balance performance
    end
end)()

-- Function to move behind the target and always face the enemy
local function moveAndFaceTarget(target)
    if not humanoidRootPart or not humanoid then return end

    -- Check if the target is valid
    local targetRootPart = target:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then return end

    -- Run a continuous loop to always stay behind the target and face it
    while getgenv().autofarm and target:FindFirstChild("Humanoid") and target.Humanoid.Health > 0 do
        -- Calculate the current distance to the target
        local currentDistance = (targetRootPart.Position - humanoidRootPart.Position).Magnitude
        
        -- Only move if the player is far enough away (greater than 3 studs)
        if currentDistance > 3 then
            -- Recalculate the position behind the target based on its LookVector (facing direction)
            local behindOffset = targetRootPart.CFrame.LookVector * -getgenv().distanceBehind
            local targetPosition = targetRootPart.Position + behindOffset

            -- Calculate the CFrame to move behind the enemy and face it
            local targetCFrame = CFrame.new(targetPosition, targetRootPart.Position)  -- Align to face the target

            -- Smooth movement with TweenService
            local tweenDuration = 1 / math.max(0.1, getgenv().tweenSpeed)  -- Prevent divide by zero
            local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
            currentTween = TweenService:Create(humanoidRootPart, tweenInfo, {CFrame = targetCFrame})
            currentTween:Play()

            -- Wait for tween to complete before updating again
            wait(tweenDuration)
        else
            -- If close enough, wait a little before checking again
            wait(0.1)
        end
    end
end

-- Function to wait until the target's Humanoid health is 0
local function waitForEnemyToDie(enemy)
    local enemyHumanoid = enemy:FindFirstChild("Humanoid")
    if enemyHumanoid then
        -- Wait until the enemy's health reaches 0
        while enemyHumanoid.Health > 0 and getgenv().autofarm do
            wait(0.1)  -- Small delay to prevent overloading
        end
    end
end

-- Function to find all enemies in the dungeon folder (with reduced frequency)
local function findEnemies()
    local enemies = {}

    -- Get the dungeon folder
    local dungeonFolder = game.Workspace:FindFirstChild("dungeon")
    if not dungeonFolder then return enemies end  -- Return empty if dungeon folder not found

    -- Search all descendants in the dungeon folder for valid enemies
    for _, obj in pairs(dungeonFolder:GetDescendants()) do
        if obj:FindFirstChild("HumanoidRootPart") and obj:FindFirstChild("Humanoid") and obj.Humanoid.Health > 0 then
            table.insert(enemies, obj)
        end
    end

    return enemies
end

-- Function to autofarm enemies
local function autoFarm()
    local lastEnemyCheck = 0  -- Keep track of the last time we checked for enemies
    
    while getgenv().autofarm do
        -- Only check for new enemies every getgenv().enemyCheckInterval seconds
        if tick() - lastEnemyCheck >= getgenv().enemyCheckInterval then
            lastEnemyCheck = tick()  -- Update the last check time

            local enemies = findEnemies()

            -- If there are enemies, start farming them
            if #enemies > 0 then
                for _, enemy in pairs(enemies) do
                    if not getgenv().autofarm then return end  -- Stop if autofarm is disabled during the loop

                    -- Continuously move behind the target and face the enemy
                    moveAndFaceTarget(enemy)

                    -- Wait for the enemy to die before moving to the next one
                    waitForEnemyToDie(enemy)
                end
            end
        else
            -- Wait a bit before the next loop iteration to save resources
            wait(0.5)
        end
    end
end

-- Start the autofarming script if enabled
if getgenv().autofarm then
    coroutine.wrap(function()
        pcall(function()
            autoFarm()
        end)
    end)()
end
